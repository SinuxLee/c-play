# **业界常用的 Lua+C 结构模式（7 大类）**

下面完全基于实际工程经验（游戏/服务端/工具链）。每一种核心思想和适用场景。

---

## **1. C 做引擎 / Lua 做逻辑**

**核心：C 控制主循环，Lua 只负责业务。**

* C 注册大量 C API → Lua 调用
* C 触发事件 → callback 到 Lua
* 逻辑热更新容易
* Lua 当“脚本层”

**代表**：游戏引擎、网游服务器。

**优点**：稳定、高性能。
**缺点**：绑定代码多，API 管理麻烦。

---

## **2. Lua 做主流程 / C 当扩展**

**核心：Lua 决定程序流，C 只是扩展库**

* Lua 写主逻辑（类似 Python）
* C 提供模块（如 filesystem, network, packet 等）
* 扩展像 LuaJIT-FFI、luvit 等生态

**优点**：业务非常灵活，开发快。
**缺点**：Lua 负责调度→性能瓶颈可能在 Lua 层。

---

## **3. 双线程/双驱动：C 负责性能关键，Lua 执行业务流**

这是方案 1 和 2 的混合进化版。
**常见于 MMO、手游框架：**

* 主循环在 C
* 事件由 C 推送到 Lua
* Lua 决定当次事件需要哪些 C 功能
* C 和 Lua 都可能主动调用对方

**特点**：

* 灵活的分层
* 全局控制权在 C
* Lua 执行业务逻辑状态机、AI、技能、配置解析

**优点**：业界主流。
**缺点**：需要非常谨慎的 API 边界设计。

---

## **4. 数据驱动：Lua 只提供数据/配置，逻辑主要在 C**

**核心：Lua 用来组织数据，不执行大量逻辑。**

例如：

```lua
return {
    monster = {
        hp = 100,
        atk = 30,
        ai = "aggressive"
    }
}
```

C 读取这些表，再跑自己的逻辑。

**代表**：高性能 C 游戏引擎、UE4 早期蓝图前的脚本模式。

**优点**：性能极高。
**缺点**：Lua 价值大幅下降，可玩性低。

---

## **5. 消息驱动（Lua 事件系统）** — C 抽象为消息，Lua 负责处理

C 不直接调用 Lua 函数，只做：

```
Event("ON_LOGIN", payload)
Event("CAST_SKILL", payload)
```

Lua 中存在：

```lua
On("CAST_SKILL", function(skillId, caster, target)
    ...
end)
```

**优势**：

* C 层极简
* Lua 层完全数据驱动和事件驱动
* 热更新容易
* 网络/场景/AI 都非常好组织

**代表产品**：Roblox（类似思想）、许多大型手游框架

---

## **6. Lua VM 池 / 多 VM 分区架构**

针对**服务器或高并发应用**：

* 每个玩家一个 Lua VM
* 或每个房间一个 VM
* C 做资源调度
* VM 之间通过消息通信

**优点**：强隔离，热更新非常稳。
**缺点**：内存占用大，需要池化优化。

---

## **7. LuaJIT FFI 模式（跳过绑定，直接调用 C 结构体/函数）**

**核心：用 LuaJIT FFI 替代传统绑定。**

```lua
local ffi = require("ffi")
ffi.cdef[[
    int add(int a, int b);
]]

print(ffi.C.add(1, 2))
```

**优点**：快得离谱
**缺点**：无法用在非 JIT 环境（比如 iOS），兼容性差

适用于：

* 工具链
* PC/服务器
* 插件生态

---

# **8. C 和 Lua 双热更新系统（高级）**

C 提供：

* 动态加载 C 插件（.so/.dll）
* Lua 热更新逻辑
* 双层插件架构

Lua 做：

* 配置
* 流程
* 可热修复代码

**优点**：灵活度满格
**缺点**：维护难度极高，不适合小团队。

---

# **总结：设计方式完整列表**

| 编号 | 模式              | 控制权      |
| -- | --------------- | -------- |
| 1  | C 主控 + Lua 业务   | C        |
| 2  | Lua 主控 + C 扩展   | Lua      |
| 3  | 混合驱动（双控制）       | C 主导     |
| 4  | 数据驱动模式（Lua 配置表） | C        |
| 5  | 消息驱动模式          | Lua      |
| 6  | VM 池 / 多 VM 架构  | C        |
| 7  | LuaJIT FFI      | Lua      |
| 8  | C+Lua 双插件热更新系统  | C+Lua 双控 |

---


# **核心说明：市面上的主流产品实际上都不是单一模式，而是 1 + 3 + 5 的混合架构。**

即：

* **C 做主控**（性能、资源、线程、网络）
* **Lua 做逻辑**（业务、AI、脚本、配置）
* **事件/消息驱动 Lua 层**

---

# **1. Skynet（游戏服务器框架）**

### **Skynet 使用的模式**

✔ **模式 6：多 Lua VM / 多服务模型**
✔ **Lua 主控部分流程 + C 提供核心模块**（模式 2 + 3）
✔ **消息驱动（内部协议/actor 模型）**（模式 5）

### **简述**

* 每个 service 是一个独立 Lua VM
* C 实现网络、定时器、协程调度
* Lua 写业务（逻辑脚本、玩家、房间）

### **评价**

**这是现今服务器端最主流的 Lua 架构之一。**

---

# **2. Cocos2d-x（手游引擎）**

### **Cocos2d-x 使用的模式**

✔ **模式 1：C++ 引擎 + Lua 逻辑脚本**
✔ **模式 5：事件驱动 + 回调式 Lua 绑定**
✔ **强绑定 API（大量 C++ 开 Lua）**

### **简述**

* C++ 实现渲染、物理、动画、UI
* Lua 负责游戏逻辑、UI 行为、配置
* 大量自动绑定（tolua++ / lua-binding）

### **评价**

**标准的 C 主控 + Lua 业务。手游行业里最典型的架构。**

---

# **3. LÖVE / love2d（轻量 Lua 游戏框架）**

### **love2d 使用的模式**

✔ **模式 2：Lua 主控，C 提供模块**
✔ **C 几乎完全不参与逻辑**

### **架构图**

Lua entry point
↓
Lua 调用 love.graphics、love.event 等 C 模块
↓
C 层只有基础功能，没有控制流程

### **评价**

**Lua 为主 → 更像 Python/JS 的脚本应用框架。**

---

# **4. Roblox（Luau）**

### **Roblox 使用的模式**

✔ **消息驱动（模式 5）是核心**
✔ **C++ 引擎负责一切底层（模式 1）**
✔ **Lua（Luau）执行逻辑（模式 3）**

### **评价**

**全球最大 Lua 生态，典型的 C 主控 + Lua 事件系统。**

---

# **5. World of Warcraft / 暴雪（游戏插件）**

### **采用的模式**

✔ **模式 2：Lua 主控 UI**
✔ **C++ 游戏引擎提供安全的 API**
✔ **事件驱动（模式 5）**

### **评价**

**Lua 写 UI 与行为逻辑，底层全部封闭。**

---

# **6. Garry’s Mod（Source Engine）**

### **使用模式**

✔ **模式 1：C++ 主控引擎**
✔ **Lua 做 mod / UI / 游戏逻辑**
✔ **大量 C 导出 API**

---

# **7. nginx + Lua（openresty）**

### **使用模式**

✔ **LuaJIT + C（模式 7）**
✔ **嵌入式 Lua VM + C 事件模型（模式 3）**

### **评价**

**高性能服务端脚本的典范。**

---

# **8. Redis + Lua 脚本**

### **使用模式**

✔ **C 主控（模式 1）**
✔ **Lua 只用于执行事务逻辑（模式 4 + 2）**

---

# **9. Unity + Lua（手游常见方案）**

### **使用模式**

✔ **C# 主控（等价于 C）**
✔ **Lua 做逻辑、热更（模式 1 + 5）**

### **评价**

几乎所有手游用的 Lua 脚本方案都长这样（xlua、tolua、slua）。

---

# **10. 腾讯/网易/字节大型游戏服务器（多数）**

### **实际采用的模式**

✔ **典型：C++/Go 主控 + 多 Lua VM（模式 3+6）**
✔ **业务事件推给 Lua（模式 5）**
✔ **执行 AI、技能、战斗、物品逻辑（模式 1）**

**结论：业内大型项目基本都使用“C 主控 + Lua 执行业务”的混合模式。**

---

# **总结：市场主流使用分布（靠近真实情况）**

| 产品/类型                       | 主流架构模式           |
| --------------------------- | ---------------- |
| 游戏引擎（Cocos, Roblox, UE Lua） | **模式 1 + 5**     |
| 轻量游戏框架（love2d）              | **模式 2**         |
| MMO/手游服务器（Skynet, 大型网游）     | **模式 3 + 5 + 6** |
| 渲染引擎/图形应用                   | **模式 1**         |
| 工具链/脚本处理（openresty）         | **模式 7**         |
| Web 服务器（openresty）          | **模式 7 + 3**     |
| 客户端 UI（WOW, UI 系统）          | **模式 2 + 5**     |

**绝大多数商业游戏（客户端+服务器）都使用：
→ C 主控（性能） + Lua 逻辑（灵活/热更） + 消息驱动。**
